---
layout: single
title: "Performance guideline for Blueprints and making sense of Blueprint VM."
excerpt: In this post I'll go through common myths about Blueprint performance bottlenecks and explain real logic behind it's virtual machine.
header:
  teaser: /assets/images/per-post/blueprint-performance/bluemans-bp-horror.png
author: Meta
category: Videogames Development
tags:
  - Blueprints
---

You can see many people telling these innocent lies all over the place:

- Avoid tick, it's expensive
- Use timers instead of tick
- Do not use cast, its expensive
- Prefer interfaces instead of casting 
- Use timelines instead of tick

and sadly there are many projects following those advices, especially the ones implement 100% Blueprints without any C++ code. So over the time I ended up developing a motivation to research how Blueprints works behind the scenes, and decided to write an article about it. So today we are going to go through those common myths and explain why they are incorrect, and analyze *actual* problems of Blueprint system. 😎

But before going through myths, let's examine how Blueprints virtual machine actually works behind the scenes, so we can reason logic behind it.

# Understanding the infastracture of Blueprint system.

Blueprints is a visual and *interpreted* language that is implemented on top of Unreal Engine 3's UnrealScript virtual machine. As todays date, it outperforms old UnrealScript VM, but also shares most of the limitations of it, like not being able to expose arrays of arrays to reflection system. (Yes, that's why you can't have arrays of arrays directly.)

If you go through `UnrealTypes.h`, `CodeGenerator.h` and `Object.h` in source code, you can see the legacy comments in the code that implies reflection types are actually sharing tech debts from old Unreal Engine 3 code.

Also another proof, a slideshow from Epic, presented in 2014 to developers:

![Slideshow from 2014.](/assets/images/per-post/blueprint-performance/ue-tech-debt-sucks.png)

[Click me for source](https://www.slideshare.net/GerkeMaxPreussner/east-coast-devcon-2014-game-programming-in-ue4-game-framework)

## Compiled languages vs. interpreted languages

Compiled languages (C/C++, Rust, Erlang) are converted into machine code directly, so they end up being faster than interpreted languages by skipping the "interpretation" step (which also introduces many other steps, as every language has a different way to interpret the code), but they have a "build" step that happens *offline*. Which means developer has to compile the code everytime when they make a change before running the code.

Interpreted languages (Java, Python, Blueprints) are not compiled into machine code but they include an intermediate program (interpreter) that runs the code *line by line* and executes in different ways. Some interpreters like C#'s and Lua's Just-In-Time compiler converts high-level human readable code into low-level machine code *runtime*, meanwhile some interpreters like Blueprint's and Java's generate a bytecode before running the code and executes the code going through bytecodes.

Basically compiled languages introduce a program named "compiler" that translates human readable code into machine code *before* you execute it, and interpreters introduce another concept named "interpreter" and converts your code into something else that main program and execute *in runtime*.

**When you press compile button in blueprint graph, blueprint compiler generates bytecode for your blueprint nodes and engine executes your code by going through that bytecode.**

If you are curious, you can see the generated bytecode in *human readable* format, by putting these lines into your DefaultEngine.ini and check your output log:
```
[Kismet]
CompileDisplaysBinaryBackend=True
```

You can see the all possible instructions blueprint compiler can generate as bytecode in `EKismetCompiledStatementType` which is defined in `BlueprintCompilerStatement.h`.

## Blueprints is essentially something like a "machine" that keep doing calls to C++.

Blueprints is actually an *embedded* scripting language like Lua. It has a deep relationship with reflection system and UObject framework.

### TL;DR Embedded languages 101:

- Embedded languages provide an API that can be integrated into target application. So embedded languages interact with the *host* program (like game engine, in our case)
- *In theory* any language can be embedded into an application (like a game engine, in our case) but some languages are specifically designed to make this process easier.
- The more complex the language, the more it's difficult to embed it to an application. Lua is a great example for easy-to-embed languages. It's lightweight as possible and very easy to interact with.

- Blueprints specifically created for Unreal Engine, that you can expose data to Blueprint system from C++ code with reflection system and Blueprint system can call exposed C++ functions and can interact with other reflected types.

### So what does that mean?

Like every other language, Blueprints has a specific goal; and it's to make developer's life easier. Epic Games specifically focused on helping artists to involve into the development progress by having a "visual" scripted language. They wanted to provide developers an ecosystem that they can both use C++ and their new visual scripting system efficiently.

So since it's an embedded language, it can interact with Unreal Engine's existing frameworks, that's why I always tend to think *at most simple level* it's actually nothing but a system that keeps doing calls to C++ side of the engine. 

If you ignore everything about blueprints, you can still see Unreal Engine has a UObject framework with an abstract reflection system that you can build anything on top of it. So to interact with Unreal Engine, you need to build a scripting language that can access *that* framework. And that's what Blueprints system is doing. Blueprints VM, in fact, allows you to implement *any other* scripting language on top of it's abstract implementation. [You can see Hazelight's AngelScript implementation as an example](https://angelscript.hazelight.se/).

Understanding this fact will help you easier what I mean by a "machine" that keep doing calls to C++.

# Performance of Blueprints.

Blueprints have "direct" and "indirect" overheads. There is only one "direct" overhead of blueprints system:

## [Every function "call" has the same exact overhead](https://youtu.be/j6mskTgL7kU?t=1144). 

Everytime blueprint VM evaluates a function, it just runs a code to invoke the a C++ function. And even if you have a function/event you created in Blueprint graph, you just end up calling functions declared in C++ inside of it. Because when you start up a fresh project in launcher, every existing function you can add to blueprint graph is defined in C++ side of the engine. Events that automatically added to graph when you create a new one, like `BeginPlay`, `Tick`, `OnBeginOverlap` are also actually C++ functions called by engine. 

- **So only "direct" overhead of blueprints system is that VM calling C++ functions behind the scenes. And luckily, it has exact same overhead for each node!**
- **So best we can do to optimize a blueprint code is to reduce the count of existing nodes!** 
- **Avoiding cast node, or not using tick event won't solve any problem!**

----

In below, we are going to talk about "indirect" overhead of blueprints.

## Pure nodes can be dangerous, because they are evaluated each time they're plugged to an input parameter.

There are two type of Blueprint functions: 

- Impure nodes
- Pure nodes

### Impure Nodes

![An impure function.](/assets/images/per-post/blueprint-performance/impure-node.png)

- Impure nodes are blue nodes that has an input and output execution pins. 
- When impure nodes are evaluated, we can think like their output params are also instanced as local variables in the blueprint graph. So each time you call an impure function, Blueprint VM will create (hidden) local variables for each output parameter. So if any of the output params are connected to one of the next function's input parameters, BP VM will access to created hidden local variable and use it.
- **If you have multiple output params that are expensive to copy (like multiple non-primitive types like vectors, rotator and custom structs), you should prefer using an impure function.**

### Pure nodes

![A pure function.](/assets/images/per-post/blueprint-performance/pure-node.png)

- Pure nodes are green nodes that does not have any input or output execution pins.
- When a pure node evaluated, they are being (re)called each time they are plugged to an input parameter of any function.
- You should never have expensive to run functions as pure nodes because of that.
- They work best for providing references of objects and simple (blocks of) math operations.
- **"Get" nodes of variables are also pure functions.**
- **Use pure nodes with caution when you are in a loop body. Prefer to cache variables before running a loop and accessing the cached variables instead.**

## Macros, Functions and Collapsed Graphs in Blueprint.

Macros are special nodes that their context is copy pasted into graph *during blueprint compilation process.* They introduce two problems:

- They are slowing down the compilation process. (But unless you have hundreds of them, this should not be a concern.)
- They can hide nodes behind a single node, so blueprint graph might look cute and innocent but it might be a gigantic sphagetti of nodes behind the scenes. 
- A great example for this is `For Each Loop` macro. **The reason looping containers expensive in blueprints are because "for loop" is actually a set of blueprint nodes and if you loop something too many times BP VM end up evaluating too many nodes for such a simple action.** For this reason, if you have a bottleneck in a specific blueprint graph, it's always a good idea to convert Blueprint loops into C++ loops.

See behind the scenes of `For Each Loop` and `Gate` macros:

Macros work best when: 

- When you have latent tasks but you need to use same code multiple times over the code.
- Very simple actions like checking validity of something or checking a condition of something. (i.e. things like IsValid() macro and HasAuthority() macro)
- [Flow control utils](https://landelare.github.io/2022/04/29/reverse-flip-flop.html)

## How input/output params of functions are being set behind the scenes.

For each blueprint callable function, engine generates a custom struct type in C++ (you can find this struct in `.generated.cpp` file after compilation if you are a programmer). This struct contains every input and output variable of the function. And whenever that function is called, engine fills that struct with the values you provide and invokes the function. 

- **So each time you call a function, there is a cost of setting variables per input and output params.**
- **But in modern computers this is such a cheap operation and almost NEVER a performance concern.**

### Setting a variable means "copying it".

As said, modern computers can handle a simple operation like setting a variable, **but we should not forget setting a variable means *copying* a value to it.** For example, if you do:

```c
float myValue = 3.f;
float myNewValue = myValue;
```

you would copy 4 bytes of value from `myValue` to `myNewValue`. And this is *perfectly* fine. But what if you copy something like this?:

```c
FVector vectorArray[4096];
Fvector newVectorArray[4096] = vectorArray
```

you would copy around 50 kilobytes of data (12 bytes * 4096). (which is still fine for a modern cpu unless you repeat this action multiple times at once, but Blueprints does this all over the place and hides this operation in front-end user interface)

And since every output param (and unless you expliciptly mark your input refs as "ref") is a copy of the value you plugged, you should not copy arrays or should not have too many output params.

For example, a while ago someone posted this image in reddit and people thought of what would happen if you actually run this function:

![A pure function.](/assets/images/per-post/blueprint-performance/too-many-params.png)

Before seeing the overhead of the function, you would see the overhead of your CPU trying to copy values for input params and overhead of instantiating them as (hidden) variables. 

There is a reason Blueprints is a *scripting* language, and you should avoid writing system architecture with it.

### Make and Break nodes of structs

For each struct you have in your project, Unreal Engine generates a default `Make` and `Break` nodes. These nodes aren't different than other functions in term of input/output param handling. So each time you use a `Break Hit Result` node you end up copying almost every variable in the hit result. 

But this should never be a concern, because I actually profiled the performance of a gigantic struct like `Break Hit Result` and results was relieving:

`0.01ms per 350 node in Shipping`

# Myths

## 1: Avoid tick, it's expensive.

As we explained above, only direct overhead of Blueprints system is function invoking overhead. And a simple tick event won't destroy your performance on it's own, but the nodes connected to your tick event will run every frame and memory access to instructions can end up being way slower than C++ code. **Unless you are going to ship to a low-end hardware like PS4, do not avoid tick at every situation.** Always profile your game in shipping config at lowest hardware target.

I wanted to provide data about overhead of executing a single empty tick node, but I don't have access to low-end hardware to profile it. Though if you are desperate for info about this, I have *heard* calling around 300 empty tick nodes in a single frame costs around 1ms per frame. But one way or another, never believe someone who is telling something is expensive before you see it in profiler with your own eyes.

## 2: Use timers instead of tick.

[No.](https://www.reddit.com/r/unrealengine/comments/wq7cke/comment/ikltr2r/?utm_source=share&utm_medium=web2x&context=3)

Also don't forget the red square pin you are plugging an event to `Set Timer by Event` is a dynamic delegate (event dispatcher, in BP terms) and it's expensive to call. 100 BP ticks vs 100 Dynamic Delegate invoking will end up in a result dynamic delegates causing more of overhead than BP ticks. 

`Set Timer by Function Name` is even worse because engine will go through all blueprint callable events of your class to find the given function with the name so there is additional lookup time overhead compared to `Set Timer by Event`.

## 3: Do not use cast, its expensive

"Cast" itself is nothing but a fancy loop that goes through class hierachy data in reflection system. If the given class type is found the loop, engine does a C-style cast to given type (which is... literally free for CPU to execute) and returns a pointer to it.

The reason people say "cast is expensive" is, when you *reference* something in your *blueprint class*, engine automatically loads those references along with your blueprint. **[You should prefer using soft references and design your systems properly to avoid loading half of the game with a single blueprint class.](https://youtu.be/j6mskTgL7kU?t=2364)** I've seen "blueprint function libraries" that has reference(s) to boss characters of the game in *input parameters* of functions, and end up loading at least 2GB of data to memory for no reason. 🤦‍♂️

## 4: Do not use cast, its expensive

Interfaces are some sort of "[multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance)" thing and their existence is not because to replace casts. 

An interface is a description of the actions that an object can do. for example when you flip a light switch, the light goes on, you don't care how, just that it does. One actor might implement it in X way, other actor might implement in Y way. This is when interfaces come useful.

In fact, behind the scenes engine actually does a cast to access the interface in given object, so people using interface because of the "Do not use cast" myth is actually not ending up avoiding any cast. 

## 5: Use timelines instead of tick

Each timeline node ends up being a component in your actor class and costs memory. They are great for evaluating curves, they also provide some cool inline curve editor that you can open and edit your curves inside of the actor's blueprint graph, but it has disadvantages too:

- Each timeline node also ends up being another "tick function register" for engine's "tick manager". 
- Tick manager queues, updates and checks the state of the registered tick functions. So having too many timelines can result in a slight bottleneck for tick manager.
- Having too many timelines cause actor to instantiate and *register* (which is surprisingly more expensive than instantiating) a component. So it ends up making actor more expensive to spawn.

I'd say, *use timelines*, but *do not replace tick with them.* They are good for sequential ticks that are enabled and disabled at specific times, and also they should be used for evaluating curves too.

----

That was all. Thanks for reading! Share this article to help people avoid myths! 😊

